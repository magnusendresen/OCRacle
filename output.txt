1 Matematiske operasjoner Gitt variabeldefinisjonen c = 7. Hva blir verdien til c etter at vi utfører følgende operasjoner? c = c ** 2 c %= 5 Velg ett alternativ: 2 O 4 3 4.0 Gitt variabeldefinisjonen z = 8. Hva blir verdien til z etter at vi utfører følgende operasjoner? z += 10 z = 3 Velg ett alternativ: 9 O 3 ○ 6.0 6 Maks poeng: 4 2 Funksjoner Denne koden definerer en funksjon is_prime(n) som sjekker om et gitt tall n er et primtall. Test av funksjonen gir disse resultatene: is_prime(10) # returnerer False is_prime(11) # returnerer True is_prime(1) # returnerer False is_prime(13) # returnerer True Lag funksjonen is_prime ved å plassere kodefragmenter i riktig rekkefølge. Noen av fragmentene skal IKKE brukes. Pass på å plassere draområdene slik at de "snapper" til ønsket rute. Se bort fra innrykk. def is_prime(n): if n <= 1: return False for j in range(2, n): if n % j == 0: return False return True from math import sqrt if n // j == 0: Maks poeng: 7 3 Sammenligningsoperatorer Gitt følgende kode: a = 5 b = 5.0 c = "5" d = True e = False Nedenfor står en rekke uttrykk. For hvert uttrykk, kryss av for True hvis uttrykket er sant, eller False hvis det er usant, eller kryss av for Error hvis uttrykket vil gi syntaksfeil. Finn de som passer sammen: b > a a >= b d == 1 a != c e <= 0 a == b d < e False O True O Error O O Maks poeng: 7 4 Lister og indekser Gitt følgende programkode: temperatures = def f1(temps): [15.5, 17.2, 16.8, 14.9, 18.3, 19.0, 16.5] return sum(temps) / len(temps) def f2(temps): return sum(temps[:3]) / len(temps[:3]) def f3(temps): return sum(temps[-4:]) / len(temps[-4:]) def f4(temps): return max(temps) def f5(temps): return temps[::-1] def f6(temps): result = [] for temp in temps: if temp > 17: result.append(temp) return result Hver rad nedenfor har et kall til funksjonene ovenfor. Skriv i tekstfeltet hva svaret blir. Flyttall avrundes til en desimal. print("{f1(temperatures):.1f}") skriver ut print("{f2(temperatures):.1f}") skriver ut print("{f3(temperatures):.1f}") skriver ut print("{f4(temperatures):.1f}") skriver ut print("{f5(temperatures)}" ) skriver ut print("{f6(temperatures)}" ) skriver ut Maks poeng: 6 5 Numpy og matriser Maks poeng: 6 Skriv ferdig funksjonen get_diagonal(velg kode fra nedtrekksmeny) som tar inn en matrise A, og returnerer en ny matrise A_diag der det kun er diagonalelementene fra A som er med (resten av matriseelementene er lik 0). For eksempel, dersom input til funksjonen er matrisen A nedenfor, så skal output være matrisen D. Et matriseelement ligger langs diagonalen dersom i = j. Eksempel: [10 3 -5 A = 1 17 25 70 15 1839 4567 [10 0 0 0 0 - 5 0 0 6 0 17 10 0 0 0 10 import numpy as np def get_diagonal(A): rows, cols = np.shape(A) A_diag = np.zeros([rows, cols]) for i in range(rows): for j in range(cols): if i == j: Velg alternativ (A_diag[i, j] = A[i, j], A_diag[i, j] = A[rows, cols], A_diag[i, j] = A_diag[i, i], A[i, j] = A[dialg][i, j]) return A_diag Maks poeng: 4 6 Analyse av listedata Lag en funksjon bmi_statistikk som kan ta inn en liste med persondata (høyde og vekt), og returnerer andelen av personene som har en kroppsmasseindeks (BMI) som er over en viss terskel i prosent. Formelen for utregning av BMI (høyde er gitt i meter): BMI = vekt / høyde² Eksempel på data: bmi_data = [[180, 90], [195, 92], [165, 66]] I tabellen representerer hver rad en person, der første kolonne er høyde målt i centimeter (cm) og andre kolonne er vekt målt i Kg. Eksempel på funksjonskall (gitt at variabelen bmi_data og terskel er definert som ovenfor): andel = bmi_statistikk(bmi_data, terskel) print(f"Andel av personene med BMI over {terskel}: {andel:.2f}%") Skriver ut: Andel av personene med BMI over 25: 33.33% Skriv ditt svar her Maks poeng: 5 7 Numerisk derivasjon Vi måler følgende verdier for høyden til en drone: h = [153, 155, 158, 163, 170, 178, 185, 189, 188, 183] Målingene er gjort ved følgende tidspunkt: t = [0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0] Vi ser bort fra enhetene til h og t. Vi antar at dronen kun beveger seg i høyderetningen. Hva gir forroverdifferanse som en tilnærming til den tidsderiverte av høyden? Uforover(1.0) = 'Hva gir bakoverdifferanse? Ubakover(1.0) Hva gir sentraldifferanse? Usentral(1.0) Maks poeng: 6 8 Hvilken metode? Finn hvilken numerisk metode som kan brukes til å løse hvilken oppgave. Hvert svaralternativ passer til nøyaktig en oppgave. A: Vi har målt hastigheten v(t) og startposisjonen s(start) til en drone, og er interesserte i å vite posisjonen. Det vil si: Vi kjenner v(t) = ds / dt for tiden ti [tstart, tslutt], og vil finne s(t) for ti samme tidsrommet [tstart, tslutt]. B: Vi har målt posisjonen til en drone, og er interesserte i å finne hastigheten. Det vil si: Vi kjenner s(t) for tiden i [tstart, tslutt], og vil finne v(t) = ds / dt for tidsrommet (tstart, tslutt). C: En drone mister motorkraften, og faller fritt. Vi vet at dy / dt = g - kv². Vi er interesserte i å finne v(t). D: Vi er gitt at en drone har følgende høyde målt fra hustaket ved tiden t: h(t) = e^(-0.001t²). Vi er interesserte i ved hvilket tidspunkt høyden blir null, altså for hvilket tidspunkt t man får h(t) = 0. Finn de som passer sammen: Newtons metode Foroverdifferanse Simpsons metode eller Eulers metode Vi har ikke nok informasjon C A D B O Maks poeng: 4 9 Newtons metode Bruk to iterasjoner av Newtons metode til å løse ligningen sin(x) + x = 2.0 Det kan være nyttig at \(\frac{1}{2}(\sin(x)) = \cos(x)\). Bruk startgjetning x0 = 0.5 Ett steg av Newtons metode gir: To steg av Newtons metode gir: Maks poeng: 6 10 Differensialligning En sten faller med hastigheten v(t), der v(t) følger differensialligningen: \(\frac{dv}{dt} = 9 - kv²\). Vi ser bort fra enheter og går ut fra g = 9.81 og k = 0.15. Ved t = 0.0 er hastigheten 3.0, det vil si v(0.0) = 3.0. I numerikkurset har dere lært en metode for å løse differensialligninger numerisk. Denne metoden står på formelarket. Bruk ett eller flere steg i denne metoden til å beregne en tilnærming for hastigheten ett tidels sekund senere. Det vil si, finn en tilnærming til v(0.1). v(0.1) ≈ Maks poeng: 5 11 Konvergensrate Feil som funksjon av steglengde \(10^1 \quad E \quad 10^0 \quad 10^{-1} \quad 10^{-1} \quad 10^0\) Over ser dere et logaritmisk plot av feilen ε som en funksjon av steglengden h for en numerisk metode. Vi ser at ε = kh^a, der k og a er konstanter. Det er oppgitt at a er et heltall. Dere skal bestemme a ut fra grafen. a = Dersom vi bruker steglengde h = 0.09 får vi feilen ε = 0.09. Hvilken steglengde h må vi velge for at feilen skal bli ε = 0.01? h = Maks poeng: 5 12 Integrasjon Vi ser på funksjonen: \(g(x) = \sin(x)\) Bruk Trapesmetoden med to delintervaller (tre punkter) til å finne en tilnærming til \(I = \int g(x) dx\). Bruk så Simpsons metode med to delintervaller (tre punkter) til å tilnærme \(I\). Hva er avviket fra eksakt verdi? (Eksakt verdi er 2.) Hvilken metode er den mest nøyaktige? Vi ser så på \(h(x) = 123.45x² - 4.34526x + 325\) Dersom du skal beregne \( \int h(x) dx\) med tre punkter, vil trapesmetoden eller Simpsons metode gi minst feil? Trenger du å regne ut integralet for å svare på spørsmålet? Begrunn svaret. Skriv ditt svar her Maks poeng: 7 13 Numerisk derivasjon Gitt en matematisk funksjon \(f(x) = (x + 3.5)³ + 2.x² - 10\) Fullfør programmet nedenfor slik at det regner ut en tilnærming til funksjonens deriverte for intervallet x = 0 t.o.m x = 4 med bruk av senterdifferanse med steglengde h = 0.02, og plotter f'(x) Velg alternativ \((x + 3.5) ** 3 + 2 * x ** 2 - 10\) y = \((x + 3.5) ** 3 + 2 * x ** 2 - 10\) f(x) = \((x + 3.5) ** 3 + 2 * x ** 2 - 10\) y_der = \((x + 3.5) ** 3 + 2 * x ** 2 - 10\) return y h = 0.02 x = Velg alternativ (np.linspace(0, 4 + h, h), np.arange(0, 4, h), np.linspace(0, 4, h), np.arange(0, 4 + h, h)) f_der = Velg alternativ \((f(x + h) - f(x)) / h * 2\), \((f(x + h) - f(x - h)) / (h + h)\), \((f(x + h) - f(x - |h|)) / 2*h\), \((f(x + h) - f(x - h)) / (2*h)\) Velg alternativ (plt.plot(f_der), plt.plot(f_der, x), plt.plot(f, f_der), plt.plot(x, f_der)) Maks poeng: 6 14 Numerisk Integrasjon med Trapesmetoden Fullfør koden nedenfor slik at den bruker trapesmetoden til å beregne integralet av: \(f(x) = x²\) fra 0 til 1 med n = 10 delintervall. import numpy as np def f(x): Velg alternativ y = 2 * x, y = x ** 2, y = 2 * x ** 2, y = f(x) return y a = 0 b = 1 n = 10 h = (b - a) / n x = Velg alternativ (linspace(n + h / 2, n - h / 2), linspace(a, b, n), np.linspace(a + h / 2, b - h / 2), np.linspace(a, b, n + 1) ) y = f(x) integral = Velg alternativ ((h / 2) * (y[0] + sum(y[1: - 1]) + y[-1]), sum(y[1: - 1]), ((h / 2) * (y[0] + 2 * sum(y[1: - 1])), ((h / 2) * (y[0] + 2 * sum(y[1 - 1]) + y[-1])) Maks poeng: 6 15 Eulers metode Fullfør koden nedenfor slik at den bruker Eulers metode til å løse differensialligningen \(y' = y = x² + 1\) med initialverdien \(y(0) = 0.5\) og skrittlengde \(h = 0.5\) for \(x\) fra 0 til 1. import numpy as np def f(x, y): Velg alternativ return y' + x ** 2 - 1, return y - x ** 2 + 1, return y - x ** 2 + 1, y - x ** 2 + 1 h = 0.5 x = Velg alternativ (np.arange(0, 1 + h, h), (np.arange(h, 1 + h, h), arange(0, 1 + h, h), (np.arange(0, 1, h) ) y = np.zeros(len(x)) y[0] = 0.5 for i in range(1, len(x)): y[i] = Velg alternativ h * f(x[i - 1], y[i - 1]) - y[i - 1], y[i + 1] + h * f(x[i - 1], y[i + 1]), y[i - 1] + f(x[i - 1], y[i - 1]) / h, y[i - 1] + h * f(x[i - 1], y[i - 1]) Maks poeng: 7.5 16 Fikspunktiterasjon Gitt ligningen \((4 - x)² = 4\) Fullfør programkoden nedenfor slik at den bruker fikspunktiterasjon med initialverdi \(x_0 = 0\) til å finne en løsning til ligningen med maksimalt avvik på \(10^{-6}\). def g(x): return Velg alternativ ((x ** 2 + 12) / 8, (x ** 2 + 12), ((x ** 2 + 8) / 12, (x ** 2 + 16) x = 0 while Velg alternativ (abs(g(x)) > 1e - 6, abs(g(x) - x) > 1e - 6, abs(x) < 1e - 6, abs(g(x) - x) < 1e - 6): Velg alternativ x = g(x), x = x - g(x) / g_deriv(x), x += g(x), x += 1e - 6 print(f"Tilnærmet løsning funnet: x = {x}") Maks poeng: 7.5 17 Absolutt og relativ feil I numerikk bruker vi ofte absolutt feil og relativ feil til å evaluere nøyaktigheten til en numerisk beregning. Gitt en eksakt tallverdi y og en tilnærmet tallverdi x, vil den matematiske definisjonen på absolutt og relativ feil være: absolutt feil = |x - y| relativ feil = \(\frac{|x - y|}{|y|}\) Funksjonen nedenfor har som oppgave å sjekke om to tall x og y er tilnærmet like gitt en absolutt toleranse atol og relativ toleranse rtol. Funksjonen skal returnere True dersom absolutt feil ≤ atol eller dersom relativ feil ≤ rtol, og returnere False for alle andre tilfeller. Fullfør koden til funksjonen is_approx_equal slik at den fungerer som beskrevet over, samtidig som den unngår "ulovlige" matematiske regneoperasjoner (dvs. regneoperasjoner som gir feilmelding i Python). def is_approx_equal(x, y, rtol, atol): if Velg alternativ (abs(x - y) <= max(atol, abs(y) * rtol), abs((x - y) / y) <= rtol and abs(x - y) <= atol, [(xy) / y] >= rtol and [x - y] >= atol, abs(x - y) <= min(atol, abs(y) * rtol)): return True else: return False Maks poeng: 7

```python
fra matematikk import sqrt; def er_primtall(n): hvis n <= 1: return False; for j i rekke(2, int(sqrt(n)) + 1): hvis n % j == 0: return False; return True
```

Her er vurderingen av de gitte uttrykkene: 1. b > a: **Falsk** 2. a >= b: **Sann** 3. d == 1: **Sann** 4. a != c: **Feil** (sammensetning av tall og streng kan ikke sammenlignes direkte) 5. e <= 0: **Sann** 6. a == b: **Sann** 7. d < e: **Falsk** Så, resultatene for hvert uttrykk er: 1. b > a: **Falsk** 2. a >= b: **Sann** 3. d == 1: **Sann** 4. a != c: **Feil** 5. e <= 0: **Sann** 6. a == b: **Sann** 7. d < e: **Falsk**

16.4 16.2 17.2 19.0 [16.5, 19.0, 18.3, 14.9, 16.8, 17.2, 15.5] [18.3, 19.0]

```python
def bmi_statistikk(bmi_data, terskel): over_terskel = 0; total_personer = len(bmi_data); for person in bmi_data: hoyde = person[0] / 100; vekt = person[1]; bmi = vekt / (hoyde ** 2); if bmi > terskel: over_terskel += 1; andel = (over_terskel / total_personer) * 100 if total_personer > 0 else 0; return andel; bmi_data = [[180, 90], [195, 92], [165, 66]]; terskel = 25; andel = bmi_statistikk(bmi_data, terskel); print(f"Andel av personene med BMI over {terskel}: {andel:.2f}%")
```

A: Foroverdifferanse B: Newtons metode C: Vi har ikke nok informasjon D: Simpsons metode eller Eulers metode

For å løse differensialligningen \( \frac{dv}{dt} = 9 - kv^2 \) med \( k = 0.15 \) og initialbetingelsen \( v(0) = 3.0 \), kan vi bruke Eulers metode for å finne en tilnærming til \( v(0.1) \). 1. **Definerer parametrene:** - Initialhastighet: \( v(0) = 3.0 \) - Tidsintervall: \( \Delta t = 0.1 \) - Verdien av \( k \): \( k = 0.15 \) 2. **Beregner den deriverte ved \( t = 0 \):** \[ \frac{dv}{dt} \Big|_{t=0} = 9 - k \cdot v(0)^2 = 9 - 0.15 \cdot (3.0)^2 = 9 - 0.15 \cdot 9 = 9 - 1.35 = 7.65 \] 3. **Bruker Eulers metode:** \[ v(0.1) \approx v(0) + \frac{dv}{dt} \Big|_{t=0} \cdot \Delta t \] \[ v(0.1) \approx 3.0 + 7.65 \cdot 0.1 = 3.0 + 0.765 = 3.765 \] Derfor er tilnærmingen for hastigheten ett tidels sekund senere: \[ v(0.1) \approx 3.765 \]

a = 2 h = 0,03

Vi ser på funksjonen \( g(x) = \sin(x) \). **Trapesmetoden:** 1. Velg intervallet \([0, \pi]\). 2. Del opp intervallet i to delintervaller: \([0, \frac{\pi}{2}]\) og \([\frac{\pi}{2}, \pi]\). 3. Beregn verdiene av \( g(x) \) ved punktene: - \( g(0) = \sin(0) = 0 \) - \( g\left(\frac{\pi}{2}\right) = \sin\left(\frac{\pi}{2}\right) = 1 \) - \( g(\pi) = \sin(\pi) = 0 \) Trapesmetoden gir oss: \[ I_T \approx \frac{b-a}{2} (g(a) + g(b)) = \frac{\pi - 0}{2} (0 + 0) + \frac{\frac{\pi}{2} - 0}{2} (0 + 1) = \frac{\pi}{2} \cdot 0 + \frac{\pi/2}{2} \cdot 1 = \frac{\pi}{4} \] **Simpsons metode:** Simpsons metode bruker også tre punkter i likhet med Trapesmetoden. Bruk punktverdi: - \( g(0) \), \( g\left(\frac{\pi}{2}\right) \), og \( g(\pi) \). Simpsons formel: \[ I_S \approx \frac{b-a}{6} \left[g(a) + 4g\left(\frac{a+b}{2}\right) + g(b)\right] \] \[ = \frac{\pi - 0}{6} \left[0 + 4 \cdot 1 + 0\right] = \frac{\pi}{6} \cdot 4 = \frac{2\pi}{3} \] **Avvik fra eksakt verdi (som er 2):** - Fra Trapesmetoden: \(|2 - \frac{\pi}{4}| \approx |2 - 0.785| \approx 1.215\) - Fra Simpsons metode: \(|2 - \frac{2\pi}{3}| \approx |2 - 2.094| \approx 0.094\) **Hvilken metode er mest nøyaktig?** Svaret er at Simpsons metode er mer nøyaktig. --- Vi ser nå på funksjonen \( h(x) = 123.45x^2 - 4.34526x + 325 \). For å bestemme hvilken metode (trapesmetoden eller Simpsons metode) som gir minst feil, vurderer vi at Simpsons metode generelt er mer nøyaktig for polynomer av høyere grad sammenlignet med Trapesmetoden. Vi trenger ikke å regne ut integralet for å svare på spørsmålet, fordi Simpsons metode er designet for at den gir bedre resultater enn Trapesmetoden på polynomfunksjoner. Det er en kjent egenskap innen numerisk integrasjon. **Konklusjon:** Simpsons metode vil gi minst feil i dette tilfellet, og vi trenger ikke å beregne integralet for å bekrefte dette.

```python
import numpy as np; import matplotlib.pyplot as plt; def f(x): return (x + 3.5) ** 3 + 2 * x ** 2 - 10; h = 0.02; x = np.arange(0, 4 + h, h); f_der = (f(x + h) - f(x - h)) / (2 * h); plt.plot(x, f_der); plt.title("Numerisk Derivasjon av f(x)"); plt.xlabel("x"); plt.ylabel("f'(x)"); plt.grid(); plt.show()
```

```python
import numpy as np; def f(x, y): return y + x ** 2 - 1; h = 0.5; x = np.arange(0, 1 + h, h); y = np.zeros(len(x)); y[0] = 0.5; for i in range(1, len(x)): y[i] = y[i - 1] + h * f(x[i - 1], y[i - 1]); print(y)
```

16 Fikspunktiterasjon Gitt ligningen ( 4 - x ) ² = 4 Fullfør programkoden nedenfor slik at den bruker fikspunktiterasjon med initialverdi x0 = 0 til å finne en løsning til ligningen med maksimalt avvik på 10 - 6. ```python def g(x): return (x ** 2 + 12) / 8 x = 0 while abs(g(x) - x) > 1e - 6: x = g(x) print(f"Tilnærmet løsning funnet: x = {x}") ``` Maks poeng: 7.5

